//go:build ignorepackage

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of int type names; must be set")
)

const (
	sizeFuncTmpl = `
func (es *%s) Size() int {
	return len(*es)
}
`
	cloneFuncTmpl = `
func (es *%s) Clone() Elements {
	nArray := make(%s, es.Size())
	copy(nArray, *es)
	return &nArray
}
`
	dtypeFuncTmpl = `
func (es *%s) DType() DType {
    return %s
}
`
	iGetFuncTmpl = `
func (es *%s) IGet(i int) (e Element, err error) {
	if i > es.Size() {
		err = errors.New(fmt.Sprintf("index out of slice with length %%d", es.Size()))
		return
	}
	e = (*es)[i]
	return
}`
	iSetFuncTmpl = `
func (es *%s) ISet(i int, e Element) (isNaN bool, err error) {
	if i > es.Size() {
		err = errors.New(fmt.Sprintf("index out of slice with length %%d", es.Size()))
		return
	}
	var v %s
	v, isNaN = e.%s()
	if isNaN {
		return
	}
	(*es)[i] = %s(v)
	return
}
`
)

type Generator struct {
	buf bytes.Buffer
}

func (g *Generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	return src
}

func main() {
	flag.Parse()
	if len(*typeNames) == 0 {
		log.Fatal("-type must be set")
	}
	pkgName, fileName := os.Getenv("GOPACKAGE"), os.Getenv("GOFILE")

	gen := new(Generator)
	gen.printf("// Code generated by \"go run gen_elements.go\"; DO NOT EDIT.\n")
	gen.printf("package %s", pkgName)
	gen.printf("\n")
	gen.printf("import (\n")
	gen.printf("\"errors\"\n")
	gen.printf("\"fmt\"\n")
	gen.printf(")\n")
	gen.printf("\n")

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileName, nil, 0)
	if err != nil {
		log.Fatal(err)
	}
	ast.Inspect(f, func(n ast.Node) bool {
		decl, ok := n.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			return true
		}
		for _, spec := range decl.Specs {
			vspec := spec.(*ast.TypeSpec)

			elementsType := vspec.Name.Name

			arrayType, ok := vspec.Type.(*ast.ArrayType)
			if !ok {
				continue
			}
			identType, ok := arrayType.Elt.(*ast.Ident)
			if !ok {
				continue
			}
			gen.printf(sizeFuncTmpl, elementsType)
			gen.printf("\n")
			gen.printf(cloneFuncTmpl, elementsType, elementsType)
			gen.printf("\n")
			dtype := identType.Name
			dtype = dtype[:1] + dtype[2:]
			gen.printf(dtypeFuncTmpl, elementsType, dtype)
			gen.printf("\n")
			gen.printf(iGetFuncTmpl, elementsType)
			gen.printf("\n")
			typeFuncName := identType.Name[2:]
			t := identType.Name[2:]
			t = strings.ToLower(t[:1]) + t[1:]
			gen.printf(iSetFuncTmpl, elementsType, t, typeFuncName, identType.Name)
			gen.printf("\n")
		}
		return true
	})

	src := gen.format()
	fNames := strings.Split(fileName, ".")
	baseName := fmt.Sprintf("%s_gen.go", fNames[0])
	outputName := filepath.Join(".", strings.ToLower(baseName))
	err = ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}
